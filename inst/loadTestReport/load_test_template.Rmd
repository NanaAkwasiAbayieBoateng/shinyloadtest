---
title: "Load Test Results"
output: 
  html_document:
    df_print: paged
params: 
  url:
    label: "Deployed URL"
    value: "https://"
  concurrent:
    label: "Number of Concurrent Connections"
    value: 4
  duration:
    label: "Duration of Test (secs)"
    value: 360
  baseline:
    label: "Duration of Baseline Test (secs)"
    value: 60
  testFile:
    label: "Path to Load Test Script"
    value: "./tests/myloadtest.R"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE)
library(shinyloadtest)
library(ggplot2)
```

Load test run against `r params$url`. The load test target was **`r params$concurrent` concurrent visits** for **`r params$duration/60` minutes.** Each "user" ran a series of actions against the application as recorded in `r params$testFile`.

```{r runTest, warning = FALSE}
loadTestLog <- loadTest(testFile = params$testFile, 
                        url = params$url,
                        numConcurrent = params$concurrent,
                        testDurationSec = params$duration)
saveRDS(loadTestLog, file = "loadTestLog.Rds")
```

A baseline test was run for **`r params$baseline/60` minute(s) ** with 1 concurrent session at a time.

```{r}
baselineLog <- loadTest(testFile = params$testFile, 
                        url = params$url,
                        numConcurrent = 1,
                        testDurationSec = params$baseline)
saveRDS(baselineLog, file = "baselineLog.Rds")
```


## Results

```{r}
errors <- getErrors(loadTestLog)
loadTestLog <- getSuccesses(loadTestLog)

baseline_errors <- getErrors(baselineLog)
baselineLog <- getSuccesses(baselineLog)

```


The load test was started at `r min(loadTestLog$time)` and ended at `r max(loadTestLog$time)`.`r length(unique(loadTestLog$connection))` total connections were successful. 

```{r}
if (errors > 0) {
  print(paste0("There were ", errors, " unsuccessful sessions during the load test."))
  
}

if (baseline_errors > 0) {
  print(paste0("There were ", errors, " unsuccessful sessions during the baseline test."))
  
}
```

A maximum `r getMaxConcurrent(loadTestLog)` concurrent connections were achieved, compared to the target of `r params$concurrent`.

## Sustained Concurrent Connections

```{r concurrent_over_time}
res <- getConcurrentOverTest(loadTestLog)

ggplot(res, aes(x = time, y = connections)) + 
  geom_point(alpha = 0.25) + 
  geom_smooth() +
  geom_hline(yintercept = params$concurrent, color = "maroon") +
  theme_minimal() +
  labs(
    title = "Connections Over Time vs Target",
    x = "",
    y = ""
  )
```

## Comparison to Baseline

**Trimming** For all data comparisons, a burn-in sample of the first `r 2*params$concurrent` connections were removed from the load test log.

```{r trim}
loadTestLog <- trimRampUp(loadTestLog, 2*params$concurrent)
```


```{r}
load <- getPageLoadTimes(loadTestLog) 
load$type = "Under Load"

base <- getPageLoadTimes(baselineLog)
base$type = "Baseline"

results <- rbind(load, base)

ggplot(results, aes(type, load_time_sec)) + 
  geom_boxplot(aes(fill = type), alpha = 0.3) +
  theme_minimal() +
  labs(
    title = "Page Load Time",
    subtitle = paste(params$concurrent, "Concurrent Targetted"),
    y = "Load Time (sec)",
    x = "",
    color = "# of Conns Sharing R Process"
  ) +
  guides(shape = FALSE)
```

The average page load time under load was `r mean(load$load_time_sec)` seconds compared to `r mean(base$load_time_sec)` seconds with no concurrent load.

The following graph shows the response time for specific events taken after page load. The table lists any events that did not trigger an update pior to the default timeout. For inputs that do not trigger an output (i.e. applications that use action buttons) this is expected behavior.

```{r}
load <- getSetInputTimes(loadTestLog)
base <- getSetInputTimes(baselineLog)

load$type = "Under Load"
base$type = "Basline"

results <- rbind(load, base)

## look for timeouts
timeout <- aggregate(results$timedout, by = list(id  = results$input_id), FUN = sum)
n <- length(unique(load$connection)) + length(unique(base$connection))

message <- paste0(
  timeout$id, " - ",
  timeout$x, " of ", n, " timed out ",
  ifelse(timeout$x == n, " as expected. This input appears to be isolated from outputs.", 
         ifelse(timeout$x > 0, ". Warning! Some outputs did not return before the timeout.", "as expected.")))

data.frame(Results = message, stringsAsFactors = FALSE)
```


```{r}
## plot the distributions
ggplot(results, aes(type, event_time_sec)) +
  geom_boxplot(aes(fill = type), alpha = 0.4)  +
  facet_wrap(~input_id, scales = "free") +
  labs(
    title = "Application Usage",
    x = "",
    y = paste0("Event Time (sec)"),
    fill = ""
  ) +
  theme_minimal() + 
  guides(fill = FALSE)
```

## R Processes

Application latency is often the result of too many users sharing the same R process. RStudio Connect and Shiny Server Pro allow users to be spread across multiple R processes for any application.

```{r}

summariseTiming <- function(loadTestLog, label) {
  pageLoad <- getPageLoadTimes(loadTestLog)
  
  # coerce page loads into format that works with set input results
  pageLoad$input_id <-  "Page Load"
  pageLoad$event_time_sec <- pageLoad$load_time_sec
  pageLoad$load_time_sec <- NULL
  
  # get set input times and select relevant columns
  actionLoad <- getSetInputTimes(loadTestLog)
  actionLoad <- actionLoad[,c(1,4,5)]
  
  # combine results
  load <- rbind(pageLoad, actionLoad )
  
  # add whether there were shared connections
  worker <- getConnectionsPerR(loadTestLog)
  result <- merge(load, worker)
  result$type <- label
  result
}

load <- summariseTiming(loadTestLog, "Under Load")
base <- summariseTiming(baselineLog, "Baseline")

results <- rbind(load, base)

ggplot(results, aes(y = other_connections, x = event_time_sec)) +
  geom_jitter(aes(color = input_id), alpha = 0.4) + 
  geom_smooth(se = FALSE) +
  scale_color_brewer(type = "div") +
  theme_minimal() + 
  labs(
    title = "Sharing R Processes Increases Event Time",
    subtitle = "An upward sloping line indicates too many connections per R process",
    x = 'Event Time (sec)',
    y = 'How Many Other Users were Sharing the R Process',
    color = "Action"
  )

```

